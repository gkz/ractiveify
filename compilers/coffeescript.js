// Generated by LiveScript 1.3.1
(function(){
  var through, coffeeScript, convertSourceMap;
  through = require('through');
  coffeeScript = require('coffee');
  convertSourceMap = require('convert');
  function ParseError(error, src, file){
    /* Creates a ParseError from a CoffeeScript SyntaxError
       modeled after substack's syntax-error module */
    var markerLen;
    SyntaxError.call(this);
    this.message = error.message;
    this.line = error.location.first_line + 1;
    this.column = error.location.first_column + 1;
    markerLen = 2;
    if (error.location.first_line === error.location.last_line) {
      markerLen += error.location.last_column - error.location.first_column;
    }
    this.annotated = [file + ':' + this.line, src.split('\n')[this.line - 1], Array(this.column).join(' ') + Array(markerLen).join('^'), 'ParseError: ' + this.message].join('\n');
  }
  ParseError.prototype = Object.create(SyntaxError.prototype);
  ParseError.prototype.toString = function(){
    return this.annotated;
  };
  ParseError.prototype.inspect = function(){
    return this.annotated;
  };
  function compile(file, data){
    var compiled, error, map;
    compiled = null;
    try {
      compiled = coffee.compile(data, {
        sourceMap: coffeeify.sourceMap,
        generatedFile: file,
        inline: true,
        bare: true,
        literate: isLiterate(file)
      });
    } catch (e$) {
      error = e$;
      if (error.location) {
        error = new ParseError(e, data, file);
      }
      throw error;
    }
    if (coffeeify.sourceMap) {
      map = convert.fromJSON(compiled.v3SourceMap);
      map.setProperty('sources', [file]);
      return compiled.js + '\n' + map.toComment() + '\n';
    } else {
      return compiled + '\n';
    }
  }
  module.exports = compile;
}).call(this);
